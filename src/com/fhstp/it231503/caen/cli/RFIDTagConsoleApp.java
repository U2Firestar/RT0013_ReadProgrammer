package com.fhstp.it231503.caen.cli;

import com.caen.RFIDLibrary.CAENRFIDTag;
import com.fhstp.it231503.caen.rfid.RT0013;
import com.fhstp.it231503.caen.rfid.RT0013manager;

import java.util.Date;
import java.util.Scanner;

import static com.fhstp.it231503.caen.util.Helper.*;

/**
 * High level user interaction class for QLOG CAEN RT0013 RFID TAG.
 *
 * @author Emil Sedlacek / it231503
 * @implNote Using CAEN API 5.0.0
 * @see "CAEN Technical Information"
 */
public class RFIDTagConsoleApp {
    ////////////////////// Without getters and setters --- no need, is top applet
    /**
     * Stores state for the CLI app.
     */
    private CliStates cliState = CliStates.SCAN;
    /**
     * Central scanner object for user input.
     */
    private final Scanner scanner = new Scanner(System.in);
    /**
     * Flexible tag object to access tags' information.
     */
    private RT0013manager myRT0013 = new RT0013manager();
    /**
     * Array the result of inventory is saved to. Is the space to choose a tag from.
     */
    private CAENRFIDTag[] myTags = null;

    ////////////////////// Menu DATA

    /**
     * Possible state for the CLI app. Mainly menus.
     */
    enum CliStates {
        SCAN,
        CHOOSE,
        MENU1,
        MENU1_1,
        MENU1_1_3,
        MENU1_1_4,
        MENU1_1_3_1,
        EXIT
    }

    /**
     * Stores compactly strings for pre menu.
     */
    private final String[][] optionsMenu1 = {
            {"0", "RECHOOSE - Locks onto another tag."},
            {"1", "RESCAN - Scans for tags and lists them."},
            {"2", "ACCESS TAG - Continues to submenus."},
            {"x", "Exit program"}
    };
    /**
     * Stores compactly strings for main menu.
     */
    private final String[][] optionsMenu1_1 = {
            {"0", "BACK - Goes back..."},
            {"1", "READ MANUALLY - Manually reads and display registers values."},
            {"2", "FETCH MEMORY - Buffers all registers to RAM. (RECOMMENDED)"},
            {"3", "CONFIG - Inspect config of tag."},
            {"4", "DATA - Inspect data of tag."},
            {"x", "Exit program"}
    };
    /**
     * Stores compactly strings for detailed config menu.
     */
    private final String[][] optionsMenu1_1_3 = {
            {"0", "BACK - Goes back..."},
            {"1", "ABOUT - Lists most important information."},
            {"2", "RESET - FULL reset of the tag."},
            {"3", "SETUP - Starts guided reset and setup..."},
            {"4", "DIS-/ENABLE - De-/activates the tag."},
            {"5", "EDIT REGISTER - Menu for assisted register manipulations..."},
            {"6", "EXPORT CONFIG - Writes ALL REGISTER configuration to txt."},
            {"x", "Exit program"}
    };
    /**
     * Stores compactly strings for detailed register menu.
     */
    private final String[][] optionsMenu1_1_3_1 = {
            {"0", "BACK - Goes back..."},
            {"1", "EDIT CONTROL"},
            {"2", "EDIT SAMPLING DELAY"},
            {"3", "EDIT INIT DATE"},
            {"4", "EDIT ETA"},
            {"5", "EDIT BIN COUNTER ENABLER"},
            {"6", "EDIT BIN SAMPLE ENABLER"},
            {"7", "EDIT BIN TIME ENABLER"},
            {"8", "EDIT BIN HLIMITS"},
            {"9", "EDIT BIN SAMPLETIME"},
            {"10", "EDIT BIN THRESHOLD"},
            {"11", "EDIT USER AREA"},
            {"x", "Exit program"}
    };
    /**
     * Stores compactly strings for detailed data menu.
     */
    private final String[][] optionsMenu1_1_4 = {
            {"0", "BACK - Goes back..."},
            {"1", "LIST RAW DATA - Lists ALL DATA generated by tag."},
            {"2", "LIST RECENT DATA - Decodes most recent DATA generated by tag."},
            {"3", "EXPORT DATA - Writes all log TAGDATA to csv."},
            {"x", "Exit program"}
    };

    ////////////////////// BASE FUNCTIONS
    public static void main(String[] args) {
        RFIDTagConsoleApp app = new RFIDTagConsoleApp();
        app.run(args);
    }

    /**
     * Main loop the CLI is running in. Its intended subfunctions lead to menus according to enum clistate. Init functions and the main catch are called here.
     *
     * @param args First entry carries COM-Port (exp: "COM4")
     */
    public void run(String[] args) {
        try {
            System.out.println("Initializing reader, and virtual source...");
            myRT0013.myRT0013rain.openRessources(args[0]);
            do {
                switch (cliState) {
                    case SCAN -> init_searchTags();
                    case CHOOSE -> init_chooseTag();
                    case MENU1 -> menu1();
                    case MENU1_1 -> menu1_1();
                    case MENU1_1_3 -> menu1_1_3();
                    case MENU1_1_4 -> menu1_1_4();
                    case MENU1_1_3_1 -> menu1_1_3_1();
                    case EXIT -> {
                        break;
                    }
                    default -> throw new IllegalStateException("Unexpected value: " + cliState);
                }
            } while (cliState != CliStates.EXIT);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            init_resetTagRegister();
        }
    }

    /**
     * This function loops through the process of finding a tag.
     */
    private void init_searchTags() {
        myTags = null;
        while (myTags == null || myTags.length == 0) {
            if (myTags != null) {
                System.out.print("No tags found! Are the tags on the field?\nPress 'x' to exit or any other key to continue/retry: ");
                if ("x".equals(scanner.nextLine().trim())) {
                    cliState = CliStates.EXIT;
                    return;
                }
            }
            System.out.println("DO NOT MOVE THE TAG(S) NOW! Searching for tags...");
            myTags = myRT0013.myRT0013rain.doInventory();
        }
        cliState = CliStates.CHOOSE;
    }

    /**
     * This function loops through the process of choosing a tag amongst the found ones.
     */
    private void init_chooseTag() {
        if (myTags == null)
            return;

        System.out.println(spacer + "Tags detected:");
        for (int i = 0; i < myTags.length; i++)
            System.out.println("\t#" + i + " - " + bytesToHexstring(myTags[i].GetId()));
        int chosenTag;
        if (myTags.length > 1) {
            System.out.print(spacer + "Please choose one of the tags!\nChoice (0): ");
            chosenTag = parseShortInput(scanner.nextLine().trim().toLowerCase(), (short) 0);
        } else
            chosenTag = 0;
        if (chosenTag < myTags.length && chosenTag >= 0) {
            System.out.println("Locked onto ID: " + bytesToHexstring(myTags[chosenTag].GetId()));
            myRT0013.myRT0013rain.setTag(myTags[chosenTag]);
            cliState = CliStates.MENU1;
        } else {
            System.out.println("Error: Chosen Tagnumber is not valid!");
            //DO NOT CHANGE CLI STATE. We HAVE to set a TAG.
        }
    }

    /**
     * This function safely clears memory and closes connections.
     */
    private void init_resetTagRegister() {
        System.out.println("Resetting PC progRAM safely and closing resources...");
        myTags = null;
        myRT0013.myRT0013rain.closeResources();
        myRT0013 = null;
        scanner.close();
    }

    /**
     * Prints the compact menus.
     *
     * @param menu Compact menu to be printed.
     */
    private void printMenu(String[][] menu) {
        System.out.println(spacer + "Please choose an action:");
        for (String[] strings : menu)
            System.out.println("\t'" + strings[0] + "' - " + strings[1]);
    }

    /**
     * Pre menu to basically choose the tag.
     */
    private void menu1() {
        printMenu(optionsMenu1);
        String input = promptAndGetInput(scanner, "Action: ").trim().toLowerCase();

        switch (input) {
            case "0" -> cliState = CliStates.CHOOSE;
            case "1" -> cliState = CliStates.SCAN;
            case "2" -> cliState = CliStates.MENU1_1;
            case "x" -> cliState = CliStates.EXIT;
            default -> System.out.println("Invalid option, please try again.");
        }
    }

    /**
     * Main menu to basically choose what to do with the tag.
     */
    private void menu1_1() {
        printMenu(optionsMenu1_1);
        String input = promptAndGetInput(scanner, "Action: ").trim().toLowerCase();

        switch (input) {
            case "0" -> cliState = CliStates.MENU1;
            case "1" -> menu1_1_performManualRead();
            case "2" -> menu1_1_performRAMCOPY();
            case "3" -> cliState = CliStates.MENU1_1_3;
            case "4" -> cliState = CliStates.MENU1_1_4;
            case "x" -> cliState = CliStates.EXIT;
            default -> System.out.println("Invalid option, please try again.");
        }
    }

    /**
     * Function to guide through reading registers of the tag manually and display the results accordingly.
     */
    private void menu1_1_performManualRead() {
        System.out.println(spacer);
        short wordaddress = parseHexInput(promptAndGetInput(scanner, "Enter wordregister address according to DOC (hex, default 0x00): 0x").trim(), (short) 0x00);
        short wordsToRead = parseShortInput(promptAndGetInput(scanner, "Enter number of words (default 1): "), (short) 1);
        System.out.println(tableifyReadData(bytesToShorts(myRT0013.myRT0013rain.readTag(wordaddress, wordsToRead)), wordaddress, true));
    }

    /**
     * Function loads all available registers of tag.
     */
    private void menu1_1_performRAMCOPY() {
        System.out.println(spacer + "Fetching registers... (Takes a minute!)");
        myRT0013.bufferFetchRegisters();
    }

    /**
     * Detail menu to basically config the tag.
     */
    private void menu1_1_3() throws Exception {
        printMenu(optionsMenu1_1_3);
        String input = promptAndGetInput(scanner, "Action: ").trim().toLowerCase();

        switch (input) {
            case "0" -> cliState = CliStates.MENU1_1;
            case "1" -> menu1_1_3_performAbout();
            case "2" -> menu1_1_3_performTagReset();
            case "3" -> menu1_1_3_performGuidedConfiguration();
            case "4" -> menu1_1_3_performDisEnableTag();
            case "5" -> cliState = CliStates.MENU1_1_3_1;
            case "6" -> menu1_1_3_performExportConf();
            case "x" -> cliState = CliStates.EXIT;
            default -> System.out.println("Invalid option, please try again.");
        }
    }

    /**
     * Function to inform user about all relevant information.
     */
    private void menu1_1_3_performAbout() throws Exception {
        System.out.println(spacer + "Base information:");
        System.out.println("\t" + myRT0013.getTagID(true));
        for (RT0013.REV_TYPES revType : RT0013.REV_TYPES.values())
            System.out.println("\t" + myRT0013.getTagXRev(revType, true));
        System.out.println("\t" + myRT0013.getBATStatus(true));
        for (RT0013.BITS_STATUS bit : RT0013.BITS_STATUS.values())
            System.out.println("\t" + myRT0013.getTagStatus(bit, true));
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values())
            System.out.println("\t" + myRT0013.getLastSample(sensorType, true, true));
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values())
            System.out.println("\t" + myRT0013.getSamplesNum(sensorType, true));
        System.out.println("\t" + myRT0013.getUserArea(true, true, false));

        System.out.println("Time configuration:");
        System.out.println("\t" + myRT0013.getINITDate(true));
        System.out.println("\t" + myRT0013.getShippingDate(true));
        System.out.println("\t" + myRT0013.getStopDate(true));
        System.out.println("\t" + myRT0013.getETA(true, true));
        System.out.println("\t" + myRT0013.getSamplingDelay(true, true));

        System.out.println("\nConfiguration tables:");
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values())
            System.out.println(printTable(myRT0013.retrieveBinsConfiguration(sensorType), sensorType));
    }

    /**
     * Function to perform reset of tag after asking once.
     */
    private void menu1_1_3_performTagReset() {
        System.out.println(spacer + "You are about to reset the tag for configuration purposes! (Takes minutes!)\nRemember to export config and data before enabling the tag as a reset will be done!");
        if (!parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false)) {
            System.out.println("Aborting reset...");
            return;
        }

        // Reset tag, wait and abort
        if (!myRT0013.resetTag(true)) {
            System.out.println("Reset failed! Aborting reset...");
            return;
        } else
            System.out.println("Reset ok! Resetting the rest...");

        // Default all
        myRT0013.setTagControl(RT0013.BITS_CTRL.LE, false);
        myRT0013.setTagControl(RT0013.BITS_CTRL.DE, false);
        myRT0013.setTagControl(RT0013.BITS_CTRL.RFSL, false);
        myRT0013.setSamplingDelay((short) 0, false);
        myRT0013.setETA(0);
        for (RT0013.BIN_SENSOR_TYPES sensor : RT0013.BIN_SENSOR_TYPES.values()) {
            myRT0013.configureBins(null, sensor);
        }
        myRT0013.setUserArea("", false);
        myRT0013.bufferReset();

        System.out.println("Reset done!");
    }

    /**
     * Function to guide user through all relevant settings for starting tag-operation.
     */
    private void menu1_1_3_performGuidedConfiguration() throws Exception {
        // Offer Reset
        System.out.println("Starting the guided setup!\nDo you wish to reset the tag?");
        if (parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false))
            menu1_1_3_performTagReset();

        // Write Settings
        System.out.println("You are about to write configuration and add some more details!");
        if (!parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false)) {
            System.out.println("Aborting setup...");
            return;
        }

        // Guide through setup
        myRT0013.setINITDate(new Date());
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values()) {
            myRT0013.configureBins(promptBinConfig(sensorType, myRT0013.retrieveBinsConfiguration(sensorType), scanner), sensorType);
        }
        menu1_1_3_1_performSamplingDelayEdit();
        if (myRT0013.getSamplingDelay() > 0)
            myRT0013.setTagControl(RT0013.BITS_CTRL.DE, true);
        menu1_1_3_1_performETAEdit();
        menu1_1_3_1_performUserAreaEdit();
        myRT0013.bufferReset();

        System.out.println("Guided configuration complete! Proceed to next menu option to activate the tag!");
    }

    /**
     * Function to guide to starting/stopping tag-operation.
     */
    private void menu1_1_3_performDisEnableTag() {
        System.out.println(spacer);

        if (myRT0013.getTagControl(RT0013.BITS_CTRL.LE)) {
            System.out.println("Tag seems to be active. You could disable it but will need to reset (= start new setup) it before using it again!");
            if (!parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false)) {
                System.out.println("Aborting disablement...");
                return;
            }
            myRT0013.setTagControl(RT0013.BITS_CTRL.LE, false);

            System.out.println("Done! Remember to export config and data!");
        } else {
            System.out.println("Tag seems to be inactive. You could start the logging activity.");
            if (!parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false)) {
                System.out.println("Aborting enablement...");
                return;
            }

            System.out.println("Activating tag now...");
            myRT0013.setTagControl(RT0013.BITS_CTRL.LE, true);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if (myRT0013.getTagControl(RT0013.BITS_CTRL.LE))
                System.out.println("Tag sucessfully enabled!");
            else
                System.out.println("Tag enable failed!");
            myRT0013.bufferReset();
        }
    }

    /**
     * Function to collect ALL relevant info in order to export it to a file.
     */
    private void menu1_1_3_performExportConf() throws Exception {
        System.out.println(spacer + "You are about to export config to a txt-file!");
        if (!parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false))
            return;

        StringBuilder output = new StringBuilder("############## THIS IS A RFID RT0013 TAG CONFIG FILE ###########\n");
        output.append("\n### Base information:\n");
        output.append(myRT0013.getTagID(true)).append("\n");
        for (RT0013.REV_TYPES revType : RT0013.REV_TYPES.values())
            output.append(myRT0013.getTagXRev(revType, true)).append("\n");
        output.append(myRT0013.getBATStatus(true)).append("\n");
        for (RT0013.BITS_STATUS bitStatus : RT0013.BITS_STATUS.values())
            output.append(myRT0013.getTagStatus(bitStatus, true)).append("\n");
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values())
            output.append(myRT0013.getLastSample(sensorType, true, true)).append("\n");
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values())
            output.append(myRT0013.getSamplesNum(sensorType, true)).append("\n");

        output.append("\n### Time configuration:\n");
        output.append(myRT0013.getINITDate(true)).append("\n");
        output.append(myRT0013.getShippingDate(true)).append("\n");
        output.append(myRT0013.getStopDate(true)).append("\n");
        output.append(myRT0013.getETA(true, true)).append("\n");
        output.append(myRT0013.getSamplingDelay(true, true)).append("\n");

        output.append("\n### Configuration tables:\n");
        output.append(myRT0013.getUserArea(true, true, true));
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values())
            output.append(printTable(myRT0013.retrieveBinsConfiguration(sensorType), sensorType)).append("\n");

        output.append("\n### Low level data bin configuration:\n");
        for (RT0013.BIN_EN_TYPES binEnType : RT0013.BIN_EN_TYPES.values())
            for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values())
                for (short i = 0; i <= 5; i++)
                    output.append(myRT0013.getBinEnX(i, binEnType, sensorType, true)).append("\n");
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values())
            for (short i = 0; i <= 5; i++)
                output.append(myRT0013.getBinOptionHLIMIT(i, sensorType, true, true)).append("\n");
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values())
            for (short i = 0; i <= 5; i++)
                output.append(myRT0013.getBinOptionSAMPLETIME(i, sensorType, true, true)).append("\n");
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values())
            for (short i = 0; i <= 5; i++)
                output.append(myRT0013.getBinOptionTHRESHOLD(i, sensorType, true)).append("\n");
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values())
            for (short i = 0; i <= 5; i++)
                output.append(myRT0013.getTagAlarm(i, sensorType, true)).append("\n");
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values())
            for (short i = 0; i <= 5; i++)
                output.append(myRT0013.getBinCounter(i, sensorType, true)).append("\n");

        exportStringToTxt(myRT0013.getTagID(false) + "_conf", output.toString());
    }

    /**
     * Menu to decide which register to edit.
     */
    private void menu1_1_3_1() throws Exception {
        printMenu(optionsMenu1_1_3_1);
        String input = promptAndGetInput(scanner, "Action: ").trim().toLowerCase();

        switch (input) {
            case "0" -> cliState = CliStates.MENU1_1_3;
            case "1" -> menu1_1_3_1_performControlEdit();
            case "2" -> menu1_1_3_1_performSamplingDelayEdit();
            case "3" -> menu1_1_3_1_performInitDateEdit();
            case "4" -> menu1_1_3_1_performETAEdit();
            case "5" -> menu1_1_3_1_performBinEnXEdit(RT0013.BIN_EN_TYPES.COUNTER);
            case "6" -> menu1_1_3_1_performBinEnXEdit(RT0013.BIN_EN_TYPES.TIME_STORE);
            case "7" -> menu1_1_3_1_performBinEnXEdit(RT0013.BIN_EN_TYPES.SAMPLE_STORE);
            case "8" -> menu1_1_3_1_performBinHLimitsEdit();
            case "9" -> menu1_1_3_1_performBinSampleTimeEdit();
            case "10" -> menu1_1_3_1_performBinThresholdEdit();
            case "11" -> menu1_1_3_1_performUserAreaEdit();
            case "x" -> cliState = CliStates.EXIT;
            default -> System.out.println("Invalid option, please try again.");
        }
    }

    /**
     * Guided edit of the control register.
     */
    private void menu1_1_3_1_performControlEdit() {
        System.out.println(spacer);

        for (RT0013.BITS_CTRL bit : RT0013.BITS_CTRL.values()) {
            System.out.println(myRT0013.getTagControl(bit, true));
            switch (bit) {
                case RST ->
                        System.out.println("In the following you could change the Reset bit.\nThis will result in a partial reset!");
                case LE ->
                        System.out.println("In the following you could change the Logging Enable bit. This will start the logging activity!\nOnce stopped, the logging activity can be restarted only after the tag has been reset using the RST bit.");
                case DE ->
                        System.out.println("In the following you could change the Delay Enable bit.\nIf enabled, the first sample's acquisition is done in SAMPLING_DELAY (register) seconds after the start of the logging activity.");
                case RFSL ->
                        System.out.println("In the following you could change the RF_Sensitivity_Level bit.\nIf enabled, the performance (and battery use) in terms of reading distance and read-write speed on the tag is increased.");
            }
            if (parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false)) {
                myRT0013.setTagControl(bit, parseBooleanInput(promptAndGetInput(scanner, "Enter bit value (0): ").toLowerCase(), false));
                myRT0013.bufferReset();
            }
        }
    }

    /**
     * Guided edit of the sampling delay register.
     */
    private void menu1_1_3_1_performSamplingDelayEdit() {
        System.out.println(spacer + myRT0013.getSamplingDelay(true, true));
        System.out.println("In the following you could change the SAMPLING DELAY.\nThis register defines the delay (in seconds, 0...65535) of the first acquisition after the start of the logging activity.");
        if (parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false)) {
            myRT0013.setSamplingDelay(parseShortInput(promptAndGetInput(scanner, "Enter value (0) in sec: ").toLowerCase(), (short) 0), true);
            myRT0013.bufferReset();
        }
    }

    /**
     * Guided edit of the init date register.
     */
    private void menu1_1_3_1_performInitDateEdit() {
        System.out.println(spacer + myRT0013.getINITDate(true));
        System.out.println("In the following you could change the INIT DATE.\nThe Init Date register is used to keep track of time and it is expressed in Unix time format. Default register’s value is 0 that corresponds to midnight (UTC) January, 1 1970.");
        if (parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false)) {
            myRT0013.setINITDate(promptAndParseDateTime(scanner));
            myRT0013.bufferReset();
        }
    }

    /**
     * Guided edit of the ETA register.
     */
    private void menu1_1_3_1_performETAEdit() throws Exception {
        System.out.println(spacer + myRT0013.getETA(true, true));
        System.out.println("In the following you could change the ETA, entering seconds (Say No for entering a date!).\nThis register (in seconds, 0...2^32) defines the maximum time, computed from shipping date, required to arrive at destination. If the logging is not stopped before the ETA is reached an alarm is generated. If the value of this register is 0 the ETA alarm feature is disabled.");
        if (parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false)) {
            myRT0013.setETA(parseIntInput(promptAndGetInput(scanner, "Enter value (0) in sec: ").toLowerCase(), 0));
            myRT0013.bufferReset();
        }
        else if (parseBooleanInput(promptAndGetInput(scanner, "You also could type in a date!\n" + continueQuestion), false)) {
            Date start = myRT0013.getINITDate();
            Date end = promptAndParseDateTime(scanner);
            long diffSec = (end.getTime() - start.getTime()) / 1000; // convert to seconds
            System.out.println("The calculated time difference is: " + diffSec + " seconds. You could write this value now.");
            if (parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false)) {
                myRT0013.setETA((int) diffSec);
                myRT0013.bufferReset();
            }
        }
    }
    /**
     * Guided edit of the Bin enabling registers, featuring each bin and sensorType.
     */
    private void menu1_1_3_1_performBinEnXEdit(RT0013.BIN_EN_TYPES enType) {
        System.out.println(spacer);
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values()) {
            //Head
            System.out.print("BIN ENABLE ");
            switch (enType) {
                case COUNTER -> System.out.print("COUNTER for ");
                case SAMPLE_STORE -> System.out.print("SAMPLE STORE for ");
                case TIME_STORE -> System.out.print("TIME STORE for ");
            }
            if (sensorType == RT0013.BIN_SENSOR_TYPES.TEMPERATURE)
                System.out.println("TEMPERATURE:");
            if (sensorType == RT0013.BIN_SENSOR_TYPES.HUMIDITY)
                System.out.println("HUMIDITY:");

            // Value List
            for (short i = 0; i <= 5; i++) {
                System.out.println("\t" + myRT0013.getBinEnX(i, enType, sensorType, true));
            }

            // Edit
            System.out.print("In the following you could change the ");
            if (sensorType == RT0013.BIN_SENSOR_TYPES.TEMPERATURE) {
                if (enType == RT0013.BIN_EN_TYPES.COUNTER)
                    System.out.println("BIN ENABLE TEMPERATURE COUNTER.\nBINX_T_EN Enable(1)/Disable(0) the temperature counter for the corresponding histogram bin.");
                if (enType == RT0013.BIN_EN_TYPES.SAMPLE_STORE)
                    System.out.println("BIN ENABLE TEMPERATURE SAMPLE STORE.\nBINX_T_EN: if the BINX_T_EN bit (X=0..5) is set to 1 all the temperature sampled data values which are in the range of bin X are saved into the logging memory.");
                if (enType == RT0013.BIN_EN_TYPES.TIME_STORE)
                    System.out.println("BIN ENABLE TEMPERATURE TIME STORE.\nBINX_T_EN: if the BINX_T_EN bit (X = 0..5) is set to 1 the timestamps (2 words - Unix time format) of temperature sampled values which are in the range of bin X are saved into the logging memory. ");

            }
            if (sensorType == RT0013.BIN_SENSOR_TYPES.HUMIDITY) {
                if (enType == RT0013.BIN_EN_TYPES.COUNTER)
                    System.out.println("BIN ENABLE HUMIDITY COUNTER.\nBINX_H_EN Enable(1)/Disable(0) the humidity counter for the corresponding histogram bin.");
                if (enType == RT0013.BIN_EN_TYPES.SAMPLE_STORE)
                    System.out.println("BIN ENABLE HUMIDITY SAMPLE STORE.\nBINX_H_EN: if the BINX_H_EN bit (X=0..5) is set to 1 all the humidity sampled data values which are in the range of bin X are saved into the logging memory.");
                if (enType == RT0013.BIN_EN_TYPES.TIME_STORE)
                    System.out.println("BIN ENABLE HUMIDITY TIME STORE.\nBINX_H_EN: if the BINX_H_EN bit (X = 0..5) is set to 1 the timestamps (2 words - Unix time format) of humidity sampled values which are in the range of bin X are saved into the logging memory.");

            }
            if (parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false)) {
                // Choose bin
                short chosenNumber = parseShortInput(promptAndGetInput(scanner, "Enter binNum (0) ").toLowerCase(), (short) 0);
                if (chosenNumber < 0 || chosenNumber > 5) {
                    System.out.println("BinNum does not exist. Please restart subprogram!");
                    return;
                }
                myRT0013.setBinEnX(
                        chosenNumber,
                        enType,
                        sensorType,
                        (enType == RT0013.BIN_EN_TYPES.COUNTER || enType == RT0013.BIN_EN_TYPES.SAMPLE_STORE) && chosenNumber == 0);
                myRT0013.bufferReset();
            }
        }
    }
    /**
     * Guided edit of the Bin HLIMIT registers, featuring each bin and sensorType.
     */
    private void menu1_1_3_1_performBinHLimitsEdit() {
        System.out.println(spacer);
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values()) {
            //Head
            System.out.print("BIN HLIMIT for ");
            if (sensorType == RT0013.BIN_SENSOR_TYPES.TEMPERATURE)
                System.out.println("TEMPERATURE:");
            if (sensorType == RT0013.BIN_SENSOR_TYPES.HUMIDITY)
                System.out.println("HUMIDITY:");

            // Value List
            for (short i = 0; i <= 5; i++) {
                System.out.println("\t" + myRT0013.getBinOptionHLIMIT(i, sensorType, true, true));
            }

            // Edit
            Float newValueF = 0f;
            System.out.print("In the following you could change the ");
            if (sensorType == RT0013.BIN_SENSOR_TYPES.TEMPERATURE) {
                System.out.println("BIN TEMPERATURE HLIMIT.\nThese registers are used to set the temperature upper limit for the corresponding histogram bin. The lower level corresponds to the upper level of the previous bin. The lower level of the first bin is fixed to the lower limit of the sensor.");
                newValueF = fixedpointToFloat(sensorType, (short) 0x08C0); //Respect stock values
            }
            if (sensorType == RT0013.BIN_SENSOR_TYPES.HUMIDITY) {
                System.out.println("BIN HUMIDITY HLIMIT.\nThese registers are used to set the humidity upper limit for the corresponding histogram bin. The lower level corresponds to the upper level of the previous bin. The lower level of the first bin is fixed to the lower limit of the sensor.");
                newValueF = fixedpointToFloat(sensorType, (short) 0x0C80); //Respect stock values
            }
            if (parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false)) {
                // Choose bin
                short chosenNumber = parseShortInput(promptAndGetInput(scanner, "Enter binNum (0) ").toLowerCase(), (short) 0);
                if (chosenNumber < 0 || chosenNumber > 5) {
                    System.out.println("BinNum does not exist. Please restart subprogram!");
                    return;
                }
                myRT0013.setBinOptionHLIMIT(chosenNumber,
                        sensorType,
                        parseFloatInput(promptAndGetInput(scanner, "Enter float value (0): ").toLowerCase(), (chosenNumber == 0) ? newValueF : 0f)
                );
                myRT0013.bufferReset();
            }
        }
    }
    /**
     * Guided edit of the Bin sample time registers, featuring each bin and sensorType.
     */
    private void menu1_1_3_1_performBinSampleTimeEdit() {
        System.out.println(spacer);
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values()) {
            //Head
            System.out.print("BIN SAMPLETIME for ");
            if (sensorType == RT0013.BIN_SENSOR_TYPES.TEMPERATURE)
                System.out.println("TEMPERATURE:");
            if (sensorType == RT0013.BIN_SENSOR_TYPES.HUMIDITY)
                System.out.println("HUMIDITY:");

            // Value List
            for (short i = 0; i <= 5; i++) {
                System.out.println("\t" + myRT0013.getBinOptionSAMPLETIME(i, sensorType, true, true));
            }

            // Edit
            System.out.print("In the following you could change the ");
            if (sensorType == RT0013.BIN_SENSOR_TYPES.TEMPERATURE)
                System.out.println("BIN TEMPERATURE THRESHOLD.\nThese registers are used to define the sample interval to apply for the next acquisitions in the corresponding bin. The value is expressed in seconds.");

            if (sensorType == RT0013.BIN_SENSOR_TYPES.HUMIDITY)
                System.out.println("BIN TEMPERATURE THRESHOLD.\nThese registers are used to define the sample interval to apply for the next acquisitions in the corresponding bin. The value is expressed in seconds.");

            if (parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false)) {
                // Choose bin
                short chosenNumber = parseShortInput(promptAndGetInput(scanner, "Enter binNum (0) ").toLowerCase(), (short) 0);
                if (chosenNumber < 0 || chosenNumber > 5) {
                    System.out.println("BinNum does not exist. Please restart subprogram!");
                    return;
                }
                myRT0013.setBinOptionSAMPLETIME(chosenNumber, sensorType, parseShortInput(promptAndGetInput(scanner, "Enter value (0) in sec: ").toLowerCase(), (short) 0), true);
                myRT0013.bufferReset();
            }
        }
    }
    /**
     * Guided edit of the Bin Threshold registers, featuring each bin and sensorType.
     */
    private void menu1_1_3_1_performBinThresholdEdit() {
        System.out.println(spacer);
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values()) {
            //Head
            System.out.print("BIN THRESHOLD for ");
            if (sensorType == RT0013.BIN_SENSOR_TYPES.TEMPERATURE)
                System.out.println("TEMPERATURE:");
            if (sensorType == RT0013.BIN_SENSOR_TYPES.HUMIDITY)
                System.out.println("HUMIDITY:");

            // Value List
            for (short i = 0; i <= 5; i++) {
                System.out.println("\t" + myRT0013.getBinOptionTHRESHOLD(i, sensorType, true));
            }

            // Edit
            System.out.print("In the following you could change the ");
            if (sensorType == RT0013.BIN_SENSOR_TYPES.TEMPERATURE)
                System.out.println("BIN TEMPERATURE THRESHOLD.\nThese registers represent the threshold value for the alarm (expressed in counts) on the corresponding bin. If the bin counter value is greater or equal than the threshold value the alarm bit for the corresponding bin is set.");

            if (sensorType == RT0013.BIN_SENSOR_TYPES.HUMIDITY)
                System.out.println("BIN HUMIDITY THRESHOLD.\nThese registers represent the threshold value for the alarm (expressed in counts) on the corresponding bin. If the bin counter value is greater or equal than the threshold value the alarm bit for the corresponding bin is set.");

            if (parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false)) {
                // Choose bin
                short chosenNumber = parseShortInput(promptAndGetInput(scanner, "Enter binNum (0) ").toLowerCase(), (short) 0);
                if (chosenNumber < 0 || chosenNumber > 5) {
                    System.out.println("BinNum does not exist. Please restart subprogram!");
                    return;
                }
                myRT0013.setBinOptionTHRESHOLD(chosenNumber, sensorType, parseShortInput(promptAndGetInput(scanner, "Enter allowed counts till alarm (<unlimited>): ").toLowerCase(), (short) 0xFFFF));
                myRT0013.bufferReset();
            }
        }
    }
    /**
     * Guided edit of the User Area.
     */
    private void menu1_1_3_1_performUserAreaEdit() {
        System.out.println(spacer + myRT0013.getUserArea(true, true, true));
        System.out.println("In the following you could change the User Area.");
        if (parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false))
            myRT0013.setUserArea(promptAndGetInput(scanner, "Enter custom User data (empty): "), true);
    }
    /**
     * Detail menu to basically process the data of the tag.
     */
    private void menu1_1_4() {
        printMenu(optionsMenu1_1_4);
        String input = promptAndGetInput(scanner, "Action: ").trim().toLowerCase();

        switch (input) {
            case "0" -> cliState = CliStates.MENU1_1;
            case "1" -> menu1_1_4_performListAllData();
            case "2" -> menu1_1_4_performListRecentData();
            case "3" -> menu1_1_4_performExportData();
            case "x" -> cliState = CliStates.EXIT;
            default -> System.out.println("Invalid option, please try again.");
        }
    }
    /**
     * Plainly listing all raw data to user.
     */
    private void menu1_1_4_performListAllData() {
        System.out.println(spacer + "You are about display ALL Log data! This will take a minute and creates a LONG list!");
        if (!parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false))
            return;

        menu1_1_performRAMCOPY();
        System.out.println(myRT0013.getLogArea(RT0013.BIN_SENSOR_TYPES.TEMPERATURE, true));
        System.out.println(myRT0013.getLogArea(RT0013.BIN_SENSOR_TYPES.HUMIDITY, true));
    }
    /**
     * Listing recent interpreted data to user.
     */
    private void menu1_1_4_performListRecentData() {
        System.out.println(spacer + "You are about display most recent Log data! This will take a minute!");
        if (!parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false))
            return;

        menu1_1_performRAMCOPY();
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values()) {
            String output = displayDataTable(myRT0013.parseLogData(sensorType), sensorType, (short) 10);
            System.out.println(spacer + ((output != null) ? output : "Nothing to display!"));
        }
    }
    /**
     * Saving all interpreted data to users disk.
     */
    private void menu1_1_4_performExportData() {
        System.out.println(spacer + "You are about to export data!");
        if (!parseBooleanInput(promptAndGetInput(scanner, continueQuestion), false))
            return;

        menu1_1_performRAMCOPY();
        for (RT0013.BIN_SENSOR_TYPES sensorType : RT0013.BIN_SENSOR_TYPES.values())
            exportDataToCSV(
                    myRT0013.getTagID(false) + "_" + sensorType.toString() + "_data",
                    myRT0013.parseLogData(sensorType),
                    sensorType
            );
    }
}


